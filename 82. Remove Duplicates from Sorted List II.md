STEP1
自力で解いてみる
以下の解放で解こうとしたが解けず、答えを見た
番兵を用意して一つ前のノードとして設定
現在のノードとその次のノードが重複していなければ一つ前のノードと現在のノードをつなぐ
重複していた場合重複を抜けてから一つ前のノードの次のノードを抜けた先のノードにつなぐ

```cpp
class Solution
{
    public:
        ListNode* deleteDuplicates(ListNode* head)
        {
            if (head == nullptr)
            {
                return nullptr;
            }
            ListNode dummy(0,head);
            ListNode *prev = &dummy;
            while (prev != nullptr && prev->next != nullptr && prev->next->next != nullptr)
            {
                if (prev->next->val == prev->next->next->val)
                {
                    ListNode *curr = prev->next;
                    while (curr != nullptr && curr->next != nullptr && curr->val == curr->next->val)
                    {
                        curr = curr->next;
                    }
                    prev->next = curr->next;
                }
                else
                {
                    prev = prev->next;
                }
            }
            return dummy.next;
        }
};
```

STEP2
他の人のprを確認してコードを読みやすい形に成形
https://github.com/SanakoMeine/leetcode/pull/5
https://github.com/yus-yus/leetcode/pull/4
https://github.com/Fuminiton/LeetCode/pull/4
https://github.com/plushn/SWE-Arai60/pull/4
https://github.com/quinn-sasha/leetcode/pull/3
https://github.com/fuga-98/arai60/pull/5

dummyの値を参照しないので指定しない
dummy.next=headが冒頭に明示することで戻り値への示唆があり良いと感じた
currはチェック用のノードとして設定していたが
チェック用のノード「check_node」として設定したほうが読みやすい
それに伴いprevも変数名を変更した（prev->unique_node）
continueを使うとスッキリした、かつわかりやすいように思う
duplicated_nodeと check_nodeを比較する方法も参考になった。

```cpp
class Solution
{
    public:
        ListNode *deleteDuplicates(ListNode *head)
        {
            if (head == nullptr)
            {
                return nullptr;
            }
            ListNode dummy = ListNode();
            dummy.next = head;
            ListNode *unique_node = &dummy;
            ListNode *check_node = unique_node->next;
            while (check_node != nullptr && check_node->next != nullptr)
            {
                if (check_node->val != check_node->next->val)
                {
                    unique_node = unique_node->next;
                    check_node = check_node->next;
                    continue;
                }
                ListNode *duplicated_node = check_node;
                while (check_node != nullptr && check_node->val == duplicated_node->val)
                {
                    check_node = check_node->next;
                }
                unique_node->next = check_node;
            }
            return dummy.next;
        }
};
```

STEP3 
3回連続でミスなくサブミッション成功

```cpp
class Solution
{
    public:
        ListNode *deleteDuplicates(ListNode *head)
        {
            if (head == nullptr)
            {
                return nullptr;
            }
            ListNode dummy = ListNode();
            dummy.next = head;
            ListNode *unique_node = &dummy;
            ListNode *check_node = unique_node->next;
            while (check_node != nullptr && check_node->next != nullptr)
            {
                if (check_node->val != check_node->next->val)
                {
                    unique_node = unique_node->next;
                    check_node = check_node->next;
                    continue;
                }
                ListNode *duplicated_node = check_node;
                while (check_node != nullptr && check_node->val == duplicated_node->val)
                {
                    check_node = check_node->next;
                }
                unique_node->next = check_node;
            }
            return dummy.next;
        }
};
```
