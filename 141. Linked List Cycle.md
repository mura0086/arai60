STEP1
考えたこと
ポインタをsetに入れていって
次のポインタがsetに存在するかどうかをチェックすればよいと思った
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution 
{
    public:
        bool hasCycle(ListNode *head) 
        {
            if (head == nullptr)
            {
                return false;
            }
            set<ListNode *> st;
            ListNode *ptr = head;
            while (ptr->next != nullptr)
            {
                auto tmp = st.find(ptr->next);
                if (tmp != st.end())
                {
                    return true;
                }
                st.insert(ptr);
                ptr = ptr->next;
            }
            return false;
        }
};
```
前問レビューでの指摘を鑑み他者がこのコードを読むことを想定したとき
変数名が何を意味するのか分かりやすくするべきと考え変数名を再考。
STEP2
特に現在のノードと検出ノードの命名についてそれぞれ
current, detectedなどと省略することも可能かと考えたが
より確実に判別できるように「具体的にどのノードを指しているか」を意識させたくcurrent_node,detected_nodeとした。
setについてはすでに訪れたノードという意味合いを込めてvisitedとした。
```cpp
class Solution 
{
    public:
        bool hasCycle(ListNode *head)
        {
            if (head == nullptr)
            {
                return false;
            }
            set<int> visited;
            ListNode *current_node = head;
            while (current_node->next != nullptr)
            {
                auto detected_node = visited.find(current_node->val);
                if (detected_node != visited.end())
                {
                    return true;
                }
                visited.insert(current_node->val);
                current_node = current_node->next;
            }
            return false;
        }
};
```

ここで一つ前までのコードがポインタではなく値を保持、検索してしまっていることに気が付き以下の通りポインタをsetの型に指定する修正をした。
```cpp
class Solution 
{
    public:
        bool hasCycle(ListNode *head) 
        {
            if (head == nullptr)
            {
                return false;
            }            
            set<ListNode *> visited;
            ListNode *current_node = head;
            while (current_node->next != nullptr)
            {
                auto detected_node = visited.find(current_node);
                if (detected_node != visited.end())
                {
                    return true;
                }
                visited.insert(current_node);
                current_node = current_node->next;
            }
            return false;
        }
};
```
STEP3
ほかのコードを見てフロイドの循環検出を知り、実装してみた。
1つずつ進むslowと2つずつ進むfastという異なる速度で進む2つのポインタを用意。
サイクルがなければwhileを抜け、falseを返す。
fastとslowのポインタが重なる地点があればサイクルがあるということ。 重なった時点でtrueを返す。
ただし他コード、レビューを確認する限り本問題についてはフロイドの循環検出よりsetを使った解法が想定されているのではないか、と読みとれた。
```cpp
class Solution 
{
    public:
        bool hasCycle(ListNode *head) 
        {
            if (head == nullptr || head->next == nullptr)
            {
                return false;
            }
            ListNode *fast = head;
            ListNode *slow = head;
            while (fast != nullptr　&& fast->next != nullptr)
            {
                fast = fast->next->next;
                slow = slow->next;
                if (fast == slow)
                {
                    return true;
                }
            }
            return false;
        }
};
```
